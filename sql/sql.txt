mysql >1234
-> 는 쉬프트 엔터 누르면 나옴.
테이블 이름 1인가 2인가 잘 확인하기

컨트롤 C는 '> 에서 나올 수 있는 방법

mysql -u root -p
---

RENAME TABLE employee TO people; 테이블 이름 변경
ALTER TABLE employee RENAME TO staff; 테이블 이름 변경

DROP TABLE employee; 테이블 삭제
DROP DATABASE ITCompany; 데이터 베이스 삭제

SHOW DATABASES; 데이터 베이스 목록 보기

CREATE DATABASE ITCompany3 CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;	데이타베이스 생성
SHOW VARIABLES LIKE 'character_set_server';		캐릭터_서버 생성
SHOW VARIABLES LIKE 'collation_server';		콜렉션_서버 생성

- CREATE  TABLE  employee3 (
id  INT  AUTO_INCREMENT PRIMARY  KEY,
name  VARCHAR(50) NOT  NULL,
age  TINYINT,
position  VARCHAR(50),
hire_date  DATE
);				컬럼 설정 포함 테이블 생성

DESCRIBE employee3; 테이블 구체적으로 보기
	
SHOW TABLES; 테이블 목록 보기

CREATE DATABASE ITCompany; 데이터 베이스 만들기

USE ITCompany; 데이타베이스 선택/진입

CREATE TABLE employee (id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(50) NOT NULL,
age INT,
position VARCHAR(100)
);

CREATE TABLE employee2 (id INT AUTO_INCREMENT PRIMARY KEY,
    -> name VARCHAR(50) NOT NULL,
    -> age INT,
    -> position VARCHAR(100)
    -> );

SELECT 뽑아올 컬럼들

DESC employee; 테이블 정보 보기

INSERT INTO employee (name, age, position) VALUES ('홍길동', 33, 'salesman'), ('기안42', 38, '디자이너'), ('김코딩', 28, '개발자');
INSERT INTO employee (name, age, position) VALUES ('손흥민', 35, '마케터'), ('둘리', 20, '디자이너'), ('유재석', 42, '영업사원');
INSERT INTO employee (name, age, position) VALUES ('김가나', 27, '교사'), ('박다라', 33, '영업사원'), ('한마바', 22, '운동선수');

INSERT INTO position (position_id, position_name)
VALUES (1, '영업사원'), (2, '디자이너'), (3, '개발자'), (7, '마케터'), (5, '법무팀'), (6, 'salesman');   포지션 아이디에 맞춰 포지션 생성

DELETE FROM employee WHERE name = '한마바'; 값 지우기
DELETE FROM employee WHERE ID = '4'; 아이디 4번 지우기
UPDATE employee
-> SET position_id = 5
-> WHERE id = 5; 아이디 5번의 포지션 아이디를 5번으로 바꾸기
UPDATE position SET position_id = 7 WHERE position_id = 4; 4를 7로 바꾸기
UPDATE employee SET salary = 5500 WHERE id = 2; 아이디 2번의 연봉 바꾸기
UPDATE employee SET id = 4 WHERE id = 21; 아이디 숫자 변경

SELECT * FROM employee; 테이블 조회하기
SELECT name FROM employee;

SELECT * FROM employee LIMIT 3; 3줄만 조회하기

SELECT name, age, FROM employee; 이름, 나이 조회

select name, age, rand(), 'abc' AS 초콜릿, 1+1 from employee3 ORDER BY RAND(); 압력한 목록으로 조회

SELECT name, salary FROM people WHERE salary BETWEEN 3000 AND 4000; 연봉 3000과 4000사이 사람 조회하기
SELECT name, position FROM people WHERE position LIKE '영%'; 포지션에 영_ _ _ 사람 조회하기

SELECT * FROM employee ORDER BY age;

SELECT * FROM employee ORDER BY age DESC;

DESC employee;

SELECT * FROM employee WHERE age = 38; 나이가 38인 사람 뽑아오기

 SELECT * FROM employee WHERE age <= 30; 나이가 30보다 작거나 같은 사람 뽑아오기

 SELECT * FROM employee; 다 뽑아오기

SELECT * FROM employee WHERE age <= 35 AND position = '개발자';   나이가 35보다 작거나 같고 개발자인사람 뽑아오기

SELECT name FROM employee WHERE circle IS NULL; 서클이 놀인 사람 조히하기
SELECT name, circle FROM employee WHERE circle IS NOT NULL; 서클이 놀이 아닌 사람 조회하기

SELECT name, salary FROM employee WHERE salary > (SELECT AVG(salary) FROM employee);
			서브쿼리 이용해서 이름과 연봉 조회하기

ALTER TABLE employee ADD COLUMN salary INT; 연봉 컬럼 생성
ALTER TABLE employee ADD COLUMN salad INT AFTER age; 나이 컬럼 옆 연봉 컬럼 생성
ALTER TABLE employee ADD COLUMN salary INT NOT NULL; Null 없이 샐러리 칸 생성
ALTER TABLE employee3 ADD COLUMN salary SMALLINT; 연봉 컬럼 생성
(자료형(data type)은 SMALLINT**입니다. SMALLINT는 정수형이며, 대략 -32,768부터 32,767까지의 값을 저장할 수 있습니다.)
ALTER TABLE employee3 MODIFY COLUMN salad BIGINT; 연봉 컬럼 생성
( bigint는 정수형이고 큰 숫자 저장 가능 )

ALTER TABLE employee DROP COLUMN salad, DROP COLUMN sall; 컬럼 두 개 지우기
ALTER TABLE employee ADD COLUMN circle VARCHAR(50), ADD COLUMN gender ENUM('M', 'F'); 서클과 젠더, 컬럼 두 개 생성
ALTER TABLE employee MODIFY gender ENUM('M','F'); 젠더칸 채우기 NOT NULL노은 오류 발생
ALTER TABLE employee ADD COLUMN salad VARCHAR(50); 
ALTER TABLE employee DROP COLUMN salad;
ALTER TABLE employee MODIFY position VARCHAR(100) NOT NULL AFTER salary; 
ALTER TABLE people CHANGE grade low_high VARCHAR(50) FIRST; 컬럼 이름 바꾸기

ALTER TABLE employee ADD INDEX idx_name (name);
SHOW INDEX FROM employee WHERE Key_name = 'idx_name'
-> ;
 
UPDATE employee SET position = '영업사원' WHERE name = '홍길동';
UPDATE employee SET salary = 4000 where id = 2; 샐러리 칸에 수 입력추가하기

UPDATE employee SET gender = CASE WHEN name IN ('레이첼', '모니카', '피비')THEN 'F'ELSE 'M' END;

UPDATE employee SET circle = CASE
 -> WHEN age <= 32 THEN 'movie'
 -> WHEN age = 33 THEN 'hiking' 또는  -> WHEN age >= 31 AND age <= 39 THEN 'hiking'
 -> WHEN age >= 34 THEN 'fishing'
 -> END;

UPDATE employee SET grade = CASE
    -> WHEN salary >= 5000 THEN 'high'
    -> WHEN salary < 3000 THEN 'low'
    -> ELSE 'middle'
    -> END;

UPDATE employee SET gender = CASE
-> WHEN name IN ('레이첼', '모니카', '피비')THEN 'F'
-> ELSE 'M'
-> END;

---

SELECT * FROM employee LIMIT 3;

SELECT name, salary, circle FROM employee WHERE salary >= 3300 AND circle != 'Hiking'; 연봉 3300이상 서클이 하이킹 아닌 사람 불러오기
SELECT name, salary, circle FROM employee WHERE salary >= 3300 AND circle !=  'hiking' OR circle IS NULL; 연봉 33이상 서클이 하이킹 아닌 사람 불러오기 그리고 서클이 없는 , 조건에 해당되는 사람도 불러오기

SELECT * FROM employee WHERE position = '영업사원'; 조건에 맞는 것을 불러오기
SELECT * FROM employee WHERE NOT position = '영업사원'; 조건을 제외한 모든 것 불러오기

SELECT name FROM employee WHERE name BETWEEN '가' AND '깋'; 성이름 자음이 ㄱ인 사람 불러오기
SELECT name, salary, circle FROM employee WHERE salary BETWEEN 3000 AND 4000; 연봉 3000이상 4000이하 사람 이름 연봉,서클 조회

---
CREATE DATABASE ITKorea CHARACTER SET utf8mb4; 캐릭터 생성

SHOW VARIABLES LIKE 'character_set_server'; 캐릭터가 생성된 서버 보여주기

---
명령프롬프트 

CREATE USER 'testuser'@'admin' IDENTIFIED BY '1234';  계정생성
GRAMT SELECT, INSERT ON ITCompany.employee TO 'testuser'@'localhost';
GRAMT ALL PRIVILEGES *.* TO 'testuser' 	OPTION;

mysql -u root -p
CREATE USER 'testuser'@'localhost' IDENTIFIED BY '1234';
GRANT ALL PRIVILEGES ON *.* TO 'testuser'@'localhost';
FLUSH PRIVILEGES;

mysql -u testuser -p

localhost		로컬 컴퓨터에서 접속(ex. 터미널이나 DB 툴이 같은 서버에 있을 때)
%		모든 IP / 호스트 허용 (와일드 카드, 주의해서 사용!)
127.0.0.1 		로컬 IP.localhost와 유사하지만 TCP 소켓으로 연결됨(찾아보세요)
192.168.0.%	192.168.0.으로 시작하는 내부망 IP 대역만 허용
example.com	특정 도메인에서만 접속 가능
host1		DNS에 등록된 호스트 이름

산술연산
ROUND(~) CEIL(~), FLOOR(~)
ROUND(~,2)

exit; 나가기

use itcompany; 연결
SELECT name, salary, salary * 1.5 FROM employee; 연봉의 1.5배 값 조회하기
SELECT name, salary, salary * 1.5 AS retire FROM employee; 연봉 값 이름 변경
SELECT name, salary, (salary - age ) * 1.5 / 1.2 AS retire FROM employee;
SELECT name, salary / 3.14 AS bonus FROM employee;
SELECT name, CEIL(salary / 3.14) AS bonus FROM employee; 소수점 제외 올림 값 조회
SELECT name, FLOOR(salary / 3.14) AS bonus FROM employee; 소수점 제외 내림 값 조회

SELECT id, age, salary, GREATEST(id, age, salary), LEAST(id, age, salary) FROM employee;
SELECT MIN(salary), MAX(salary), COUNT(salary), SUM(salary), AVG(salary) FROM employee;

SELECT MIN(salary), MAX(salary), COUNT(salary), SUM(salary), AVG(salary) FROM employee WHERE salary = 30;
연봉이 30인 사람의 MIN, MAX, COUNT, SUM, AVG

SELECT name, ROUND(salary * (1 - 0.033), 2) AS salary_after_tax,salary * 9.67 AS reference_value FROM employee;
3.3% 세금 떼고 남은 연봉 계산 (이름, 실제 수령 연봉)

SELECT name, age, ABS(age - 30) AS age_diff
    -> FROM employee
    -> ORDER BY age_diff DESC;	나이에사 30을 뺸 절댓값 기준으로 숫자 높은 순 나열

SELECT
AVG(salary) AS avg_salary,
MAX(salary) AS max_salary,
MIN(salary) AS min_salary
FROM employee WHERE circle IS NOT NULL AND grade = 'MIDDLE';   서클 가입한 사람 중 학위가 미들인 연봉 평균, 최댓값, 최솟값 보기

SELECT name, salary FROM employee WHERE salary BETWEEN 2000 AND 2999; 연봉 2000대인 사람 이름과 연봉 조회

SELECT COUNT(*) AS Kim_count FROM employee
    -> WHERE name LIKE '김%';	이름이 김으로 시작하는 사람 조회
SELECT name FROM employee WHERE name LIKE '김%';	이름이 김 _ _ _ 인 사람 조회

SELECT circle, UPPER(circle) FROM employee; 서클 대문자 알파벳으로 조회
SELECT circle, LOWER(circle) FROM employee; 서클 소문자 알파벳으로 조회

SELECT CONCAT('이름 : ', name) FROM employee; 이름 나열 조회
SELECT CONCAT('회원정보 : ', name, age) AS imformation FROM employee; 이름+나이 나열 조회
SELECT CONCAT_WS(name, age, salary) AS information FROM employee; 나이+이름+연봉 나열 조회

UPDATE employee
    -> SET start_date = CASE
    ->     WHEN id = 1 THEN '2022-05-06'
    ->     WHEN id = 6 THEN '2021-03-01'
    ->     WHEN id = 3 THEN '2023-12-15'
    -> END
    -> WHERE id IN (1, 3, 6);		아이디 1,3,6에 날짜 넣기
 UPDATE employee
    -> SET start_date = '2025-07-09'
    -> WHERE start_date IS NULL;		나머지에 날짜 넣기

UPDATE employee
SET position_id = CASE
    WHEN id = 1 THEN 1
    WHEN id = 2 THEN 2
    WHEN id = 3 THEN 3
    WHEN id = 4 THEN 2
    WHEN id = 5 THEN 1
    WHEN id = 6 THEN 2
    WHEN id = 7 THEN 4
    WHEN id = 8 THEN 1
    WHEN id = 9 THEN 1
    WHEN id = 10 THEN 1
    WHEN id = 11 THEN 3
    WHEN id = 12 THEN 4
    WHEN id = 13 THEN 5
    WHEN id = 14 THEN 3
END

WHERE id BETWEEN 1 AND 14;	포지션 아이디 넣기

SELECT circle, RIGHT(circle, 2), LEFT(circle, 2) FROM employee; 단어 오른쪽 두 글자 왼쪽 두 글자 출력조회

SELECT circle, SUBSTR(circle, 2),RIGHT(circle, 2), LEFT(circle, 2) FROM employee; 단어 왼쪽 두 글자, 오른 두 글자, 남은 단어 조회

SELECT
    ->   start_date,
    ->   SUBSTR(start_date, 1, 4) AS year,
    ->   SUBSTR(start_date, 6, 2) AS month,
    ->   SUBSTR(start_date, 9, 2) AS day
    -> FROM employee;		날짜, 연도, 월, 일 조회

SELECT
    ->   SUBSTR(start_date, 1, 4) AS year,
    ->   SUBSTR(start_date, 6, 2) AS month,
    ->   SUBSTR(start_date, 9, 2) AS day
    -> FROM employee;		연도, 월, 일 조회

SELECT
    ->   name,
    ->   salary,
    ->   SUBSTR(start_date, 1, 4) AS year,   
    ->   SUBSTR(start_date, 6, 2) AS month,  
    ->   SUBSTR(start_date, 9, 2) AS day     
    -> FROM employee
    -> WHERE salary < 4000;	연봉 3000미만 사람 이름, 연봉, 입사년도월 조회

SELECT circle, LENGTH(circle), CHAR_LENGTH(circle) FROM employee;
SELECT name, LENGTH(name), CHAR_LENGTH(name) FROM employee;

---

SELECT CONCAT('HELLO', 1); 	헬로, 1 조회
SELECT 1 + 2 AS HELLO; 		1+2 값 조회

SELECT circle + age FROM employee; 서클과 나이 숫자 합치기 예시 33
SELECT CONCAT(circle, ' ', age) FROM employee; 서클과 나이 명칭 합치기 예시)하이킹33

SELECT CONCAT('|', 'ABC DEF', '|');	|ABC DEF| 조회
SELECT CONCAT('|', LTRIM('ABC DEF'), '|');	왼쪽공백제거 |ABC DEF| 조회 , 괄호 안 에이비씨에 공백이 있어도 제거해서 조회
SELECT CONCAT('|', RTRIM('ABC DEF'), '|');	오른쪽공백제거

SELECT TRUE, FALSE;

SELECT !TRUE, NOT 1, FALSE, NOT FALSE, 0, 1, !1, !0, 2, !2, NOT 0;

SELECT 0 = TRUE, 1 = TRUE, 2 = TRUE;
SELECT TRUE IS TRUE, TRUE IS FALSE, TRUE IS NOT FALSE;
SELECT (TRUE IS FALSE) IS NOT TRUE;
SELECT TRUE AND TRUE, TRUE AND FALSE, TRUE OR FALSE;

SELECT LPAD(id, 4, 0) FROM employee; 엘패드 조회
SELECT RPAD(name, 7, 'a' ) FROM employee;
SELECT REPLACE('오늘 날씨가 정말 좋구나', '날씨', '기분이'); 괄호 안 문장 출력
SELECT REPLACE (start_date, '20', '30') FROM employee; 괄호 안 숫자 출력. 거짓날짜
SELECT INSTR('ABCDEFG', 'A'), INSTR('ABCDEFG', 'B'); 괄호 안 알파벳이 몇 번째인지 조회
SELECT '01' = '1', CONVERT('01', DECIMAL) = CONVERT('1', DECIMAL); 입력 숫자가 몇 번짼지 조회
SELECT name, salary FROM employee WHERE INSTR(salary, 0) =2; 이름과 연봉 조회

SELECT circle, UPPER(circle) FROM employee WHERE age >= 30 AND age < 40;	30대의 서클명 대문자 출력(이름, 나이 포함)

SELECT CONCAT(name, ',', position) AS name_with_position
FROM employee
LIMIT 5;
		이름과 포지션을 콤마(,)로 연결해 5줄만 출력(CONCAT 사용)

 SELECT name, age,
    -> CONCAT_WS('/', name, gender, age) AS info
    -> FROM employee
    -> ORDER BY age DESC;
		이름 성별 나이를 슬래시/로 연결해 출력 CONCAT_WS 사용 이름 나이 컬럼 포함하고 나이 많은 순으로 출력

SELECT name, LEFT(name, 1) FROM employee;		이름에서 첫 글자만 추출

SELECT position, RIGHT(position, 1) FROM employee;	포지션에서 끝 글자만 추출

SELECT name, circle, SUBSTRING(circle, 2, 2) AS circle_part
    -> FROM employee;		서클에서 두 번째 글자부터 2글자 추출

SELECT name,
    -> CHAR_LENGTH(name) AS char_len,
    -> LENGTH(name) AS byte_len FROM employee;
				이름의 문자 길이와 바이트 수 출력

SELECT CONCAT('|', TRIM('ABC DEF'), '|');
SELECT CONCAT('|', LTRIM('ABC DEF'), '|');
SELECT CONCAT('|', RTRIM('ABC DEF'), '|');	TRIM, RTRIM, LTRIM 각자 실습

SELECT name, salary,
    -> IF(salary >= 4000, 1, 0) AS salary_flag
    -> FROM employee;			급여 4000이상이면 1, 아니면 0으로 이름과 함께 출력

SELECT name, CONCAT(REPEAT('*', 7 - CHAR_LENGTH(name)), name) AS padded_name
    -> FROM employee;			이름과 이름 앞에 *를 여러 번 붙여 총합 7글자가 되게 출력

SELECT name, CASE WHEN position = '개발자' THEN '프로그래머'
    -> ELSE position
    ->   END AS new_position
    -> FROM employee;			포지션에서 개발자를 프로그래머로 바꾸어 출력하시오

SELECT name, LOCATE('김', name) AS position_of_kim FROM employee;	이름에 김이 포함된 위치를 출력하시오

SELECT name, salary, CHAR(salary) AS salary_str FROM employee;	연봉을 문자형으로 변환하시오 문자형은 CHAR

SELECT circle FROM employee GROUP BY circle; 그룹을 서클별로 묶어 조회
SELECT COUNT(*) FROM employee GROUP BY circle; 그룹을 서클별로 묶어 갯수로 조회
SELECT grade, COUNT(*) FROM employee GROUP BY grade; 성적 단계별로 조회
SELECT gender, AVG(age) AS avg_age
    -> FROM employee GROUP BY gender; 성별 평균 나이 조회
SELECT grade, MAX(salary) FROM employee GROUP BY grade; 학위별로 연봉 최댓값 조회
SELECT grade, MAX(salary) AS max_salary FROM employee GROUP BY grade; 학위별로 연봉 최댓값 조회2
SELECT grade, gender, AVG(salary) FROM employee GROUP BY grade, gender; 학위별 성별포함 연봉조회
SELECT circle, COUNT(*) FROM employee WHERE circle IS NOT NULL GROUP BY circle; 서클별로 카운트 조회
SELECT grade, COUNT(*) AS count FROM employee GROUP BY grade; 학위별로 횟수 조회
SELECT circle, AVG(salary) AS avg_sal FROM employee GROUP BY circle; 서클별 연봉 조회
SELECT position, SUM(salary) AS sum_sal FROM employee GROUP BY position ORDER BY sum_sal; 포지션 별 연봉
SELECT grade, SUM(salary) AS total_salary FROM employee GROUP BY grade ORDER BY total_salary DESC; 학위별 총합연봉

SELECT circle,
    -> AVG(salary) AS avg_sal,
    -> AVG(age) AS avg_age
    -> FROM employee GROUP BY circle; 서클 별로 나이 평균 연봉 평균 조회

 SELECT position, SUM(salary) AS total_salary
    -> FROM employee
    -> GROUP BY position
    -> ORDER BY total_salary DESC
    -> LIMIT 1;			부서별 급여 총합 가장 높은 부서만 출력

select position from employee group by position; 부서별 조회

SELECT position, AVG(salary) FROM employee GROUP BY position; 부서별 연봉 평균
SELECT position, AVG(salary) FROM employee GROUP BY position HAVING AVG(salary) >= 3500; 부서별 연봉 평균 3500초과만 조회
SELECT position, AVG(salary) AS avg_salary FROM employee GROUP BY position HAVING AVG(salary) >= 3500; // 조회2
SELECT position, COUNT(*) FROM employee GROUP BY position; 부서별 인원 수 조회
SELECT position, COUNT(*) FROM employee GROUP BY position HAVING COUNT(*) >= 2; 부서별 인원 조회, 2명 이상인 경우만
SELECT position, MIN(start_date), COUNT(*) FROM employee GROUP BY position; 직책별 가장 이른 입사일, 해당 직책 인원 수 조회
SELECT circle, MIN(age) FROM employee WHERE circle IS NOT NULL GROUP BY circle; 서클별 최솟값나이
SELECT grade, SUM(salary) FROM employee GROUP BY grade HAVING SUM(salary) >= 10000;
등급별 총 급여가 10,000 이상인 경우만 출력

SELECT gender, AVG(salary) FROM employee GROUP BY gender; 성별 별 평균 급여
SELECT gender, SUM(salary) FROM employee GROUP BY gender; 성별 별 총 급여
SELECT gender,
    -> SUM(salary) AS total_salary,
    -> AVG(salary) AS avg_salary
    -> FROM employee GROUP BY gender
    -> ORDER BY total_salary DESC;		성별 총급여와 평균 급여를 합꼐 출력하되, 총급여 순으로 정렬 조회



<<<<<<< WHERE는 그룹 앞에, HAVING은 그룹 뒤에 배치 >>>>>>>> 

GROUP BY

SELECT ~(집계함수) ~ FROM ~WHERE ~GROUP BY ~HVING ~;


등급별 총급여가 만 이상인 이상만 조회

---

SELECT position, AVG(salary) FROM employee WHERE gender = 'M' GROUP BY position HAVING AVG(salary) >= 3000;
성별이 남성인 사람 중 직책별 평균 급여가 연봉 3000이상인 경우

SELECT position, COUNT(*) FROM employee WHERE start_date > '2025-01-01' GROUP BY position HAVING COUNT(*) >= 2;
2025 -01-01 이후 입사지만 대상별 부서별 인원 수가 2명 이상인 경우

SELECT circle, MIN(age) AS youngman FROM employee WHERE circle IS NOT NULL GROUP BY circle HAVING youngman <= 30;
동호회 정보가 있는 살마 중 동호회별 가장 어린 나이가 30세 이하인 경우

SELECT CONCAT(position, '(', COUNT(*), '명)') AS position_with_count
    -> FROM employee GROUP BY position;		직책별로 직책명 + 인원수를 함께 출력 예) 디자이너(3명)

SELECT position AS modified_position, COUNT(*) AS cnt
FROM employee GROUP BY modified_position;	부서별, 그 수 출력. 위 입력칸은 모다파두 포지션과 카운트로 조회
				
SELECT REPLACE(position, '사원', '매니저') AS modified_position, COUNT(*) AS cnt 
	-> FROM employee GROUP BY modified_position; 위의 것과 동일하나 부서별 목록 중 사원을 매니저로 변경

SELECT position, AVG(salary) AS avg_salary FROM employee
    -> WHERE INSTR(position, '개발') >0
    -> GROUP BY position;			개발이 들어간 부서별 평균연봉조회

SELECT INSTR('개발자', '하'); 하 가 있는 개발자 위칫값 반환하기

SELECT * FROM employee WHERE 1; 전부 나옴. 숫자 0으로 바꿈 안 나옴

SELECT position, AVG(salary) AS avg_sal, MAX(salary) AS max_sal, MIN(salary) AS min_sal FROM employee GROUP BY position;
		부서별 평균 연봉, 최댓값, 최솟값 조회
SELECT position, AVG(salary) AS avg_sal, MAX(salary) AS max_sal, MIN(salary) AS min_sal FROM employee GROUP BY position WITH ROLLUP;	NULL 포함 위에 것과 동일

SELECT  position FROM employee GROUP BY position; 그룹 내 부서 목록 조회

SELECT  position, COUNT(DISTINCT circle) AS po_cir FROM employee GROUP BY position;

SELECT AVG(salary) FROM employee; 연봉평균만 조회
SELECT * FROM employee WHERE salary > (SELECT AVG(salary) FROM employee);  연봉평균보다 많이 받는 사람 조회
SELECT * FROM employee WHERE salary = (SELECT MAX(salary) FROM employee); 최고급여 받는 사람 조회
SELECT * FROM employee WHERE start_date = (SELECT MIN(start_date) FROM employee); 가장 빨리 입사한 사람 조회
SELECT * FROM employee WHERE position = '디자이너'
    -> AND salary > ( SELECT AVG(salary) FROM employee WHERE position = '디자이너');
					디자이너 직책을 가진 사람 중 디자이너 평균보다 높은 급여 받는 사람 조회
SELECT * FROM employee WHERE salary > ANY (SELECT salary FROM employee WHERE position = '영업사원');
					영업사원 평균 연봉보다 높은 사람들 하나라도 나오면 다 조회
SELECT gender, AVG(salary) AS avg_sal, (SELECT AVG(salary) FROM employee)
AS total_avg_sal FROM employee GROUP BY gender;	성별별 평균 연봉과 현재 받고있는 평균연봉 비교조회
SELECT gender, AVG(salary) AS avg_sal, (SELECT AVG(salary) FROM employee)
	-> AS total_avg_sal, 1 FROM employee GROUP BY gender; 위와 똑같은데 오른쪽에 1 추가

SELECT name FROM employee WHERE position IN ('디자이너', '개발자'); 디자이너와 개발자 이름만 조회
SELECT name FROM employee WHERE position IN (SELECT position FROM employee WHERE salary >4000);
								급여가 4000초과하는 직원들 포지션 조회

SELECT grade FROM employee WHERE salary = (SELECT MAX(salary) FROM employee);	연봉이 제일 높은 사람 성적

select position, max(salary) from employee group by position;	포지션 최대연봉 조회
SELECT position, max_salary
FROM (
    SELECT position, MAX(salary) AS max_salary
    FROM employee
    GROUP BY position
) AS sub;						포지션과 최대연봉 서브쿼리 이용해서 조회
SELECT salary, position
    -> FROM employee
    -> WHERE (salary, position) IN (
    ->     SELECT MAX(salary), position
    ->     FROM employee
    ->     GROUP BY position
    -> );						포지션과 최대연봉 서브쿼리와 IN을 이용해서 조회

SELECT e.name, p.position_name
FROM employee e
LEFT JOIN position p ON e.position_id = p.position_id; 이름, 포지션 이름 조회

SELECT e.name, p.position_name
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id;	이름, 포지션 이름 조회. 부서별 묶음으로

SELECT e.name, e.age, p.position_name
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id;	직원 이름과 나이, 포지션명 조회
		( INNER JOIN을 통해 포지션 아이디와 이름을 연결해야만 포지션 이름을 조회할 수 있음. 그것이 마지막줄에
							포지션 아이디가 포지션 이름 조회인데도 들어가야하는 이유)
(그리고 INNER은 양쪽 테이블에서 일치하는 내용만 조회, LEFT는 왼쪽 테이블에서만 일치해도 조회하는것에서 차이
이너는 아이디가 놀이거나 한쪽이 없으면 아예 안 나오고 레프트는 왼쪽이 없으면 NULL)

SELECT p.position_name, COUNT(*) AS employee_count
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id
GROUP BY p.position_name;		
		포지션별 직원수 조회(이너에 라이트와 레프트로 교체 가능, 레프트로 할 때 카운트 수가 0인 건 NULL로 대체 조회)

SELECT e.name, p.position_name
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id
WHERE p.position_name = '개발자';	포지션이 개발자인 직원만 조회

SELECT e.name, e.age, p.position_name
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id
ORDER BY e.name;	직원이름과 포지션 이름 알파벳 순 정렬
SELECT e.name, e.age, p.position_name
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id
ORDER BY e.name DESC;	직원이름과 포지션 이름 알파벳 순 정렬(내림차순)

SELECT CONCAT(e.name,'-', p.position_name) FROM employee e JOIN position p ON e.position_id = p.position_id;
					직원 이름과 포지션 이름을 하나의 문자열로 출력(예) 홍길동 - 개발자

SELECT p.position_id, AVG(e.age)
    -> FROM position p
    -> JOIN employee e ON p.position_id = e.position_id
    -> GROUP BY p.position_id;		포지션 아이디 별 직원 평균 나이

SELECT * FROM employee
    -> WHERE position_id IN (1, 2);		포지션 아이디가 1또는2인직원조회

SELECT e.name, e.age, p.position_name
    -> FROM employee e
    -> INNER JOIN position p ON e.position_id = p.position_id
    -> WHERE age >= 30;		나이가 30 이상인 직원의 이름과 나이, 포지션

SELECT e.name, e.salary, p.position_name
 FROM employee e
JOIN position p ON e.position_id = p.position_id
WHERE (e.position_id, e.salary) IN (
SELECT position_id, MAX(salary)
FROM employee
GROUP BY position_id
);				포지션별 최고 연봉 직원 이름

SELECT circle, name, salary
FROM employee
WHERE salary IN (
SELECT MAX(salary)
FROM employee
GROUP BY circle
);				서클별 최고 샐러리

SELECT employee.name, position.position_name FROM employee JOIN position
    -> ON employee.position_id = position. position_id;		이름과 포지션 이름 조회

SELECT e.name, e.circle, p.position_name
    -> FROM employee e
    -> INNER JOIN position p ON e.position_id = p.position_id
    -> WHERE e.circle = 'movie';		서클이 영화인 사람의 이름,서클, 포지션

SELECT e.name, e.gender, p.position_name
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id
WHERE e.gender = 'F';		여성인 직원의 이름, 포지션, 성별

SELECT e.name, p.position_name
    -> FROM employee e
    -> INNER JOIN position p ON e.position_id = p.position_id
    -> WHERE p.position_name = '개발자'
    -> AND e.name LIKE '%김%';		직원 중 이름에 김이 들어가고 개발자인 직원

SELECT e.name, e.salary, p.position_name
    -> FROM employee AS e
    -> JOIN position AS p ON e.position_id = p.position_id
    -> ORDER BY e.salary DESC
    -> LIMIT 3;				
			직원과 포지션을 조인 후 연봉 순으로 상위 3명만 조회(AS넣어야 인식률 증가.안 넣음 안되는경우 있음)

SELECT e.name, e.salary, p.position_name
    -> FROM employee AS e
    -> JOIN position AS p ON e.position_id = p.position_id
    -> WHERE (e.position_id, e.salary) IN (
    ->     SELECT position_id, MAX(salary)
    ->     FROM employee
    ->     GROUP BY position_id
    -> );			포지션별 상위 연봉 1명씩 이름까지 조회

SELECT e.name, p.position_name
 FROM employee e
JOIN position p ON e.position_id = p.position_id
WHERE e.position_id IN (
SELECT position_id
 FROM employee
 GROUP BY position_id
HAVING COUNT(*) >= 3
);			포지션별 직원 수 3명 이상인 포지션의 직원 이름, 포지션 조회

SELECT e.name, p.position_name, e.salary
    -> FROM employee e
    -> JOIN position p ON e.position_id = p.position_id
    -> JOIN (
    ->     SELECT position_id
    ->     FROM employee
    ->     GROUP BY position_id
    ->     HAVING AVG(salary) >= 3000
    -> ) high_avg ON e.position_id = high_avg.position_id;
			포지션별 평균 연봉 3000 이상인 포지션의 직원,포지션,연봉

ALTER TABLE employee ADD COLUMN position VARCHAR(100); 포지션 컬럼 추가
UPDATE employee e
    -> JOIN position p ON e.position_id = p.position_id
    -> SET e.position = p.position_name;			포지션 아이디를 바탕으로 컬럼 설정 넣고 조회

SELECT name, salary FROM employee WHERE salary > (SELECT AVG(salary) FROM employee);
							전체 평균 급여보다 더 많이 받는 직원 조회(이름, 연봉)

SELECT name,position FROM employee WHERE salary > ANY (SELECT salary FROM employee WHERE position = '개발자');
							개발자 아무하고나 급여가 많은 사람 조회

SELECT position, avg_sal FROM(SELECT position,AVG(salary) AS avg_sal FROM employee
GROUP BY position)
AS dept_avg
WHERE avg_sal > (SELECT AVG(salary) FROM employee);	부서별 평균 급여가 전체 평균보다 높은 부서만 조회(부서)

SELECT name,salary FROM employee WHERE position IN (SELECT position FROM employee WHERE salary >4000);
							급여 4000 초과하는 포지션의 직원 조회
SELECT name, salary FROM employee WHERE salary > 4000;	급여 4000초과하는 직원들만 조회

SELECT e1.name, e1.circle
    -> FROM employee e1
    -> WHERE EXISTS (
    -> SELECT 1
    -> FROM employee e2
    -> WHERE e2.circle = e1.circle AND e2.salary>4000
    -> );						같은 서클에 연봉 4000초과하는 사람이 있는 직원들만 조회(이름, 동호회)

mysql> SELECT 1 FROM employee WHERE salary >= 4000; 1조회하기


---

<GROUP BY>

SELECT position, avg_sal FROM(SELECT position,AVG(salary) AS avg_sal FROM employee
    -> GROUP BY position)
    -> AS dept_avg;					부서별 평균 연봉 조회

SELECT grade AS modified_grade, COUNT(*) AS cnt FROM employee GROUP BY modified_grade;
							그레이드별 몇 명씩 있는지 조회
SELECT circle, MAX(salary) AS max_sal FROM employee GROUP BY circle;
							서클별 최대 급여
SELECT position, AVG(salary) FROM employee GROUP BY position HAVING AVG(salary) >= 3500;
							성별별 평균 급여가 3500 이상인 경우만 출력

<서브쿼리>

SELECT name FROM employee WHERE salary > (SELECT AVG(salary) FROM employee);
								전체 평균 급여보다 더 많이 받는 직원 조회
SELECT name FROM employee WHERE salary = (SELECT MAX(salary) FROM employee);
								최고 급여를 받는 사람 찾기

<JOIN> 

SELECT e.name, p.position_name
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id;		직원 이름과 나이, 포지션명 조회

SELECT p.position_name, COUNT(*) AS employee_count
FROM employee e
INNER JOIN position p ON e.position_id = p.position_id
GROUP BY p.position_name;					포지션별 직원 수 조회

SELECT e.name, p.position_name
    -> FROM employee e
    -> INNER JOIN position p ON e.position_id = p.position_id
    -> WHERE p.position_name = '개발자';				포지션이 '개발자'인 직원만 조회

SELECT p.position_name,
SUM(CASE WHEN e.gender = 'M' THEN 1 ELSE 0 END) AS male_count,
SUM(CASE WHEN e.gender = 'F' THEN 1 ELSE 0 END) AS female_count
FROM employee e JOIN position p ON e.position_id = p.position_id
GROUP BY p.position_name;			각 포지션별 남녀 성비 계산

SELECT p.position_name,
COUNT(CASE WHEN e.gender = 'M' THEN 1 END) AS male_count,
COUNT(CASE WHEN e.gender = 'F' THEN 1 END) AS female_count
FROM employee e
JOIN position p ON e.position_id = p.position_id
GROUP BY p.position_name;		각 포지션별 남녀 성비 계산2

SELECT p.position_name AS position_name,
MIN(e.age) AS '최소_나이',
MAX(e.age) AS '최대_나이'
FROM employee e JOIN position p ON e.position_id = p.position_id
GROUp BY p.position_name;		포지션별 최소 나이와 최대나이

SELECT e.circle, p.position_name, COUNT(*) AS count
FROM employee e JOIN position p ON e.position_id = p.position_id
GROUP BY e.circle, p.position_name ORDER BY e.circle, p.position_name; 서클별, 포지션별 인원수
SELECT e.circle, p.position_name, COUNT(*) AS count
    -> FROM employee e JOIN position p ON e.position_id = p.position_id
    -> GROUP BY e.circle, p.position_name ORDER BY e.circle IS NULL, p.position_name; 위에 거 null 아래로 내린 거

------------정리하기--------------

SELECT AVG(salary) AS 그_평_연 FROM employee WHERE circle = 'hiking' GROUP BY [psition rm_vud_dus > 4000 ORDER BY position;

SELECT circle, MAX(salary), MIN(salary) FROM employee GROUP BY circle WITH ROLLUP;
					입력 컬럼의 최대, 최솟값 구하기
SELECT DISTINCT circle FROM employee;
					입력 컬럼 목록 구하기
SELECT circle, COUNT(DISTINCT circle) FROM employee GROUP BY circle;
					입력 컬럼 목록과 수 구하기

id - INT - 4BYTES
name - VARCHAR(50) - 예측 평균 9 Bytes + 1~2 Bytes =>총 평균 10 Bytes
age - INT - 4Bytes

한줄에 18Bytes X 100만 줄 = 18,000,000 Bytes => 18MB X 1.3 = 23.4MB X 1.5 => 35.1MB
한줄(한 행) 용량 X 데이터 건수(행수) X 여유공간 X 예상성장률

1 KB = 1024 Bytes
1 MB = 1012 kbytes

1 MB = 1,048,576 대략 1,000,000 Bytes 정도

---예상 문제

계정 생성 - localhost 로 생성(비번 1234)
CREATE USER 'ad,in_1'@'localhost' IDENTIFIED BY '1234';

권한 부여 - ITCompany DB의 employee 테이블에 SELECT, INSERT 권한 부여
GRANT SELECT, INSERT ON ITCompany.employee TO 'ad,in_1'@'localhost';

권한 회수 - 위 DB.테이블의 INSERT 권한은 회수
REVOKE INSERT ON ITCompany.employee FROM 'ad,in_1'@'localhost';

데이터 용량 산정하는 방법
SELECT table_schema AS DB명, 
       table_name AS 테이블명,
       ROUND(data_length / 1024 / 1024, 2) AS 데이터_MB,
       ROUND(index_length / 1024 / 1024, 2) AS 인덱스_MB
FROM information_schema.tables
WHERE table_schema = 'ITCompany';

계정생성 / 권한부여 권한회수

정규화란?

SELECT RAND(); 0으로 시작하는 소수 생성 예)0.3435561434
SELECT RAND() FROM employee; 소수들 생성
SELECT * FROM employee ORDER BY RAND(); 표 내기
0 <= RAND() <1 (소수)
1 <= RAND() * 10 + 1 < 11 (소수)
       FLOOR(RAND() * 10 + 1)

---날짜, 시간 관련

CREATE TAVLE date_time (
id INT,
date1 DATE DERAULT (CURRENT_DATE),
time1 TIME DERAULT (CURRENT_DATE),
datetime1 DATETIME DERAULT CURRENT_TIMESTAMP
);						표 만들기

INSERT INTO date_time (id, date1, time, datetime1)
    -> VALUES (1, '2025-07-14', '11:55:21', '2025-07-14 11:55:21');

UPDATE date_time
    -> SET date2 = '2025-07-15',
    ->     time2 = '11:55:36',
    ->     datetime2 = '2025-07-15 11:55:36'
    -> WHERE id = 1;				표 채우기					

SELECT
    ->     LEFT(datetime2, 4) AS year,
    ->     SUBSTRING(datetime2, 6, 2) AS month,
    ->     SUBSTRING(datetime2, 9, 2) AS date,
    ->     SUBSTRING(datetime2, 12, 2) AS hour,
    ->     SUBSTRING(datetime2, 15, 2) AS minute,
    ->     SUBSTRING(datetime2, 18, 2) AS second
    -> FROM date_time;				datetime2의 값을 바탕으로 시간단위별로 뽑아내기 1

SELECT
    ->     EXTRACT(YEAR FROM datetime2) AS year,
    ->     EXTRACT(MONTH FROM datetime2) AS month,
    ->     EXTRACT(DAY FROM datetime2) AS date,
    ->     EXTRACT(HOUR FROM datetime2) AS hour,
    ->     EXTRACT(MINUTE FROM datetime2) AS minute,
    ->     EXTRACT(SECOND FROM datetime2) AS second
    -> FROM date_time;				위 방법 2

SELECT LEFT(datetime2, 4) AS yoear, SUBSTR(datetime2, 6, 2) AS month, SUBSTR(datetime2, 9, 2) AS day, SUBSTR(datetime2, 12, 2) AS hour, SUBSTR(datetime2, 15, 2) AS min, LEFT(datetime2, 2) AS sec FROM date_time WHERE id = 1; 위 방법 3

SELECT LEFT(datetime2, 4) AS yoear, MONTH(datetime2) AS month, DAY(datetime2) AS day, HOUR(datetime2) AS hour, MINUTE(datetime2) AS min, SECOND(datetime2) AS sec FROM date_time WHERE id = 1;	위 방법 4

SELECT DATE(datetime2) AS date, TIME(datetime2) AS time FROM date_time;	날짜와 시간으로 분류해 뽑아내기

UPDATE date_time SET date2 = NOW() WHERE id = 1;
UPDATE date_time SET time2 = NOW() WHERE id = 1;
UPDATE date_time SET datetime2 = NOW() WHERE id = 1; 날짜 _시간 정보 업데이트

CREATE TAVLE name_position (
id INT,
date1 DATE DERAULT (CURRENT_DATE),
time1 TIME DERAULT (CURRENT_DATE),
datetime1 DATETIME DERAULT CURRENT_TIMESTAMP
);

CREATE TABLE name_position (
    ->     id INT PRIMARY KEY,
    ->     name VARCHAR(100),
    ->     position_name VARCHAR(100),
    ->     salary DECIMAL(15, 2)
    -> );		표만들기2

INSERT INTO name_position (id, name, position_name, salary) VALUES
    -> (1, '홍길동', '영업사원', 2800),
    -> (2, '유재석', '영업사원', 4700),
    -> (3, '피비', '영업사원', 3300),
    -> (4, '조이', '영업사원', 3000),
    -> (5, '기안84', '디자이너', 3800),
    -> (6, '둘리', '디자이너', 2500),
    -> (7, '레이첼', '디자이너', 3200),
    -> (8, '김코딩', '개발자', 2700),
    -> (9, '챈들러', '개발자', 3600),
    -> (10, '아이유', '개발자', 5000),
    -> (11, '모니카', '카메터', 2500),
    -> (12, '로스', '마케터', 3800);			표 내용 넣기

CREATE VIEW name_position AS SELECT e.id, e.name, p.position_name, e.salary FROM employee e JOIN position p ON e.postion_id = p.position_id;

SELECT name, salary FROM high_salary WHERE salary > 4800;

CREATE VIEW avg_salary_by_position AS
    -> SELECT position_name, AVG(salary) AS avg_salary
    -> FROM name_position
    -> GROUP BY position_name;		직급별 평균 급여 뷰

SELECT * FROM avg_salary_by_position; 를 조회하게 만드는 코드

DROP VIEW IF EXISTS high_salary;

CREATE VIEW high_salary AS
SELECT id, name, position_name, salary
FROM name_position
WHERE salary >= 4000;		급여가 4000이상인 고소득 직원만 모은 뷰 생성

SELECT name, salary
FROM high_salary
WHERE salary > 4800;		그 중 4800이 넘는 사람의 이름과 연봉만 뽑기

CREATE VIEW avg_position AS SELECT p.position_name, ROUND(AVG(e.salary), 1) FROM employee e JOIN position p ON e.position_id = p.position_id GROUP BY p.position_id;	라운드 이용해 연봉 뷰 생성

SELECT position_name, AVG(salary) AS avg_salary
FROM name_position
GROUP BY position_name;			부서별 이름과 평균 연봉 조회

SELECT position_name, AVG(salary) AS avg_salary
    -> FROM high_salary
    -> GROUP BY position_name; 		위의 거에서 고수익 두 부서만 조회

CREATE VIEW ull_position AS SELECT * FROM employee WHERE position_id is NULL;	널 포지션 뷰 생성
SLECT * FROM null_view;									위에 거 불러오기

CREATE VIEW null_table AS SELECT * FROM employee WHERE position_id IS NULL; 널 태이블 생성
SLECT * FROM null_table;								위에 거 불러오기

SHOW FULL TABLES WHERE Table_type = 'VIEW'; 테이블 뷰만 보기
SHOW CREATE VIEW null_view; 돌 뷰 조회

CREATE VIEW null_position AS
    -> SELECT *
    -> FROM employee
    -> WHERE position_id IS NULL; 놀포지션 뷰 생성
SELECT * FROM null_position; 포지션이 없는 직원만 조회

뷰 이름 - info_masking 
DROP VIEW IF EXISTS info_masking;

CREATE VIEW info_masking AS
    -> SELECT
    ->     CONCAT(LEFT(e.name, 1), REPEAT('*', CHAR_LENGTH(e.name) - 1)) AS name,
    ->     e.age,
    ->     p.position_name
    -> FROM employee e
    -> JOIN position p ON e.position_id = p.position_id;		이름이 *로 가려진 직원의 나이와 부서 조 뷰 샹송
SELECT * FROM info_masking;					조회

update employee set age = 34 where name = '홍**'; 			홍 ** 나이 34로 만들기
select * from info_masking;						조회하기

SELECT User, HOST FROM mysql.user;	생성
DROP USER 'admin2'@'localhost';		어드민 계정 제거

SELECT name, salary, gender FROM employee WHERE salary >= 4000 UNION SELECT name, salary, gender FROM employee WHERE   gender = 'M'; 연봉이 4천이상이거나 성별 m인 사람 모두 조회(중복 제거)
SELECT name, salary, gender FROM employee WHERE salary >= 4000 UNION ALL SELECT name, salary, gender FROM employee WHERE   gender = 'M'; 위에 것과 동일. 중복 제거 없음
( 두 결과를 합쳐주는 union(중복 제거), union all(중복제거없음))
SELECT name, salary, gender FROM employee WHERE salary >= 4000 OR gender = 'M'; 위에 것과 값은 같다

SELECT id, name, 'NO_POSITION' AS type FROM employee WHERE position_id IS NULL
    -> UNION
    -> SELECT id, name, 'MOVIE_LOW_GRADE' AS type FROM employee WHERE circle = 'Movie' AND grade = 'low';
						' ' 과 ' ' 에 있는 타입이 서클로 보유하고 있는 사람의 아이디와 이름, 타입 조회

IF 문, 날짜/시간, 뷰, 계정, union/union all
IF문) SELECT name,
       IF(salary > 4000, 'High', 'Low') AS salary_level
FROM employee;

date문)
SELECT NOW() AS current_datetime;
SELECT CURDATE() AS today;
SELECT DATE_ADD(NOW(), INTERVAL 7 DAY) AS next_week;
SELECT DATEDIFF('2025-07-14', '2025-07-01') AS days_diff;

VIEW문)
CREATE VIEW high_salary AS
SELECT name, salary
FROM employee
WHERE salary > 4000;

SELECT * FROM high_salary;

계정)
CREATE USER 'admin2'@'localhost' IDENTIFIED BY '1234';
GRANT SELECT ON itcompany.* TO 'admin2'@'localhost';
FLUSH PRIVILEGES;

유니온/유니온 올
SELECT name FROM employee WHERE position_id = 1
UNION
SELECT name FROM employee WHERE salary > 4000;

SELECT name FROM employee WHERE position_id = 1
UNION ALL
SELECT name FROM employee WHERE salary > 4000;

---뷰

CREATE VIEW full_table AS
SELECT e.name, e.salary, p.position_name, e.position_id
FROM employee e
JOIN position p ON e.position_id = p.position_id;		풀 테이블 뷰
select * FROM full_table;								를 조회하는 코드

CREATE VIEW full_table1 AS
SELECT e.name, p.position_name
FROM employee e
JOIN position p ON e.position_id = p.position_id;		
select * FROM full_table1;			이름과 포지션만 조회

CREATE VIEW max_salary AS
    -> SELECT position, MAX(salary) AS max_sal
    -> FROM employee
    -> GROUP BY position;				맥스 샐러리 뷰
select * from max_salary;						를 조회하는 코드

SELECT name, salary, position_name
    -> FROM full_table
    -> WHERE (salary, position_id) IN (
    ->     SELECT salary, position_id FROM max_sal
    -> );					풀 테이블 뷰에서 이름, 연봉 부서이름 조회

CREATE VIEW circle_null_table AS
    -> SELECT * FROM employee WHERE circle IS NULL;   서클 놀 테이블 생성
select * from circle_null;				를 조회하면 employee에서 서클칸에 nul인 사람 조회

CREATE TABLE date_time1 (id INT, date1 DATE, time1 TIME, datetime1 DATETIME);		날짜 시간 테이블 생성
INSERT INTO date_time1 (id, date1, time1, datetime1) VALUES (1, NOW(), NOW(), NOW());		컬럼 추가
ALTER TABLE date_time1 ADD COLUMN date2 DATE DEFAULT (CURRENT_DATE), ADD COLUMN time2 TIME DEFAULT (CURRENT_TIME), ADD COLUMN datetime2 DATETIME DEFAULT CURRENT_TIMESTAMP;		입력당시 날짜와 시간을 바탕으로 내용 추가
INSERT INTO date_time1 (id) VALUES (2);					목록 슬롯 하나 더 추가(입력당시 시간을 바탕으로)
UPDATE date_time1 SET date1 = NOW() WHERE id =  2; date1의 값을 입력당시날짜로 입력
ALTER TABLE date_time1 MODIFY COLUMN date1 DATE NOT NULL; 
						date1의 입력칸에 null이 들어가지 않도록(바로 위에 걸 넣어야 이게 입력이 되었음)
CREATE TABLE staff (name VARCHAR(50) NOT NULL);

----------색다른 방식으로 기존의 것 만들기----------

CREATE TABLE itbank (bank_id INT PRIMARY KEY, deposit INT UNSIGNED NOT NULL DEFAULT 0, FOREIGN KEY (bank_id) REFERENCES employee(id));	테이블 생성
INSERT INTO itbank (bank_id, deposit) SELECT id, 5000 FROM employee; 값 넣기
select id, 5000 FROM employee; 조회하기

UPDATE itbank SET deposit = deposit - 5000 WHERE bank_id = 1;
UPDATE itbank SET deposit = deposit + 5000 WHERE bank_id = 2;	 고정 수치 정하기

START TRANSACTION; 수치 수정하는 거 시작하기 ( 룰백을 사용할 거라면 이거 하고 바로 세이브 포인트 지정, 그 후 룰백을 해야 오류 안 남)
UPDATE itbank SET deposit = deposit -  500 WHERE bank_id = 3; 3번 줄 지정
ROLLBACK; 모든 수치 수정값을 초기화(고정 빼고, 스타트 트랜지션을 한 후에만 가능)
COMMIT; 수정값 확정하기

SAVEPOINT after_first; 세이브포인트 지정하기
autocommit = ON	자동으로 트랜잭션 종료되니 주의
SELECT @@autocommit; autocoomit(자동 트랜잭션 종료)상태인지 확인 1이 나오면 자동커밋, 0이면 수동 커밋
SET autocommit = 0; 자동일 시 수동으로 돌리는 코드(룰백 오류일 때 사용하는 코드)

ALTER TABLE itbank ADD COLUMN last_updated DATETIME DERAULT CURRENT_TIMESTAMP; 라스트 업데이트 컬럼 추가
DELIMITER //
CREATE TRIGGER update_last
BEFORE UPDATE ON itbank
FOR EACH ROW
BEGIN
SET NEW.last_updated = CURRENT_TIMESTAMP;
END;								컨트롤 씨도 효과 없음, 아래 거 추가
 //	라스트 업데이트 컬럼 내용 넣기(delimiter // 을 하면 delimiter ; 을 할 때까지 세미콜론효과가 없다. 영원히 끝나지 않는 문장의 나열지옥 손가락떨려아~~~
DELIMITER ; 꼭 공백 누르고 세미콜론			delimiter 종료하는 코드

select * from itbank_update_log; 최근 업데이트한 로그 확인하기

-

DELIMITER &&
CREATE FUNCTION getGrade(amount INT)
    -> RETURNS VARCHAR(10)
    -> DETERMINISTIC
    -> BEGIN
    -> RETURN CASE
    -> WHEN amount >= 4000 THEN 'GOLD'
    -> WHEN amount >= 3000 THEN 'SIVER'
    -> ELSE 'BRONZE'
    -> END;
    -> END;
    -> &&

SELECT bank_id, deposit, getGrade(deposit) AS grade FROM itbank;	deoisut와 등급만 보기
SELECT name, salary, getGrade(salary) AS grade FROM employee;		이름 연봉 등급 조화


CREATE TABLE example (
f FLOAT,
d DOUBLE,
c DECIMAL(10, 5)
);		테이블 생성
INSERT INTO example (f, d, c) VALUES (0.1+0.2, 0.1+0.2, 0.1+0.2); 컬럼 추가
select round(f, 15), round(d, 15), round(c, 15) from example;

SELECT f, d, c FROM example;
select
f AS float_val,
d AS float_val,
c AS float_val,
ROUND(f, 15) AS float_rounded_15,
ROUND(d, 15) AS float_rounded_15,
ROUND(c, 15) AS float_rounded_15
FROM example;

DELIMTER //
CREATE PROCEDURE deposit_money(IN acc_id INT , IN amount INT)
BEGIN
UPDATE itbank
SET deposit = deposit + amount
WHERE bank_id = acc_id;
END;								입금 기능, 고객 계좌에 돈 추가하는 코드
//
DELIMITER;
CALL deposit_money(1, 3000);

DELIMITER //
CREATE PROCEDURE withdraw_money1(IN acc_id INT, IN amount INT)
BEGIN
UPDATE itbank SET deposit = deposit - amount WHERE bank_id = acc_id;
END;
//
DELIMITER ;					머니1인 이유 - 오타인 채로 그대로 생성해서 이름 바꿔 다시 만든거.
CALL withdraw_money1(5, 3000);			오타있는지 확인하고 넘길 것.

DELIMITER //
CREATE PROCEDURE transfer_money(IN sender_id INT,IN receiver_id INT, IN amount INT)
BEGIN
UPDATE itbank SET deposit = deposit - amount WHERE bank_id = sender_id;
UPDATE itbank SET deposit = deposit + amount WHERE bank_id = receiver_id;
END;
  //

DELIMITER ;
CALL transfer_money(14, 19, 500);

SELECT * FROM ITBANK;

DELIMITER //
CREATE PROCEDURE get_deposit(IN acc_id INT, OUT p_deposit INT)
BEGIN
SELECT deposit INTO p_deposit FROM itbank WHERE bank_id = acc_id;
END;
//

DELIMITER ;
call get_deposit(3, @deposit_amunt);
SELECT @deposit_amunt;

ALTER TABLE employee DROP FOREIGN KEY fk_position;
ALTER TABLE employee
    -> ADD CONSTRAINT fk_position
    -> FOREIGN KEY (position_id)
    -> REFERENCES position (position_id)
    -> ON DELETE RESTRICT
    -> ON UPDATE CASCADE;   괄호 앞에 공백 필수

DELIMITER //
CREATE PROCEDURE get_amount (IN acc_id INT, OUT p_amount INT)
BEGIN
SELECT deposit INTO p_amount FROM itbank WHERE bank_id = acc_id;
END;
//
DELIMITER ;
CALL get_amount(3, @d_amount);
SELECT @d_amount;

DROP PROCEDURE IF EXISTS get_amount; 기본거 삭제

DELIMITER //
CREATE PROCEDURE say_hello()
BEGIN
SELECT 'HELLO WORLD';			문자열 입력하면 저장 후 실행하는 코드
END;
//
DELIMITER ;
CALL say_hello();

DELIMITER //
CREATE PROCEDURE greetings(OUT a VARCHAR(50), OUT b VARCHAR(50))
BEGIN
SELECT 'hello' INTO a;
SET b = 'hi';
END;
//
DELIMITER ;
CALL greetings(@a, @b);		입력한 문자열 나오는 코드
SELECT @a, @b;

DELIMITER //
CREATE FUNCTION setGrade(amount INT)
RETURNS VARCHAR(10)
DETERMINISTIC
BEGINRETURN CASE WHEN amount >= 6000 THEN 'Gold'
WHEN amount >= 5000 THEN 'Sliver'
ELSE 'Broze'
END;
END;
//
DELIMITER ;
SELECT bank_id, deposit,setGrade(deposit) AS grade FROM itbank;


DELIMITER //
CREATE PROCEDURE transfer_money1 (
    IN from_id INT,
    IN to_id INT,
    IN amount INT
)
BEGIN
    UPDATE itbank
    SET deposit = deposit - amount
    WHERE bank_id = from_id;

    UPDATE itbank
    SET deposit = deposit + amount
    WHERE bank_id = to_id;
END;
//
DELIMITER ;				1번이 2번에게 500원씩 주는 쿼리문
CALL transfer_money_simple(1, 2, 500);		을 실행하게 하는 쿼리문
SELECT * FROM itbank WHERE bank_id IN (1, 2);		를 보여주는 쿼리문


---용어 정리----
 항목                의미                                   
 
 itbank            은행 계좌를 저장한 테이블 (예: 계좌 ID, 예금주, 잔액 등) 
 deposit          현재 계좌 잔액을 나타내는 칼럼                    
 bank_id          각 계좌를 식별하는 고유한 ID                    
 deposit_money() 입금 프로시저: 특정 계좌의 `deposit` 값을 증가시킴    

---sql 워크밴치

1. 등급rating이 pg 또는 G 인 영화 조회-컬럼FILM
SELECT * FROM film WHERE rating IN ('PG', 'G');

2. 제목이 'A'로 시작하고 제목 길이가 15 자 이하인 영화 조회-컬럼FILM
SELECT * FROM film WHERE title LIKE 'A%' AND title <= 15;

3. 등록일 create_date이 2006년 2월 14일인 고객을 모두 출력-컬럼CUSTOMER
SELECT * FROM customer WHERE DATE(create_date) = '2006-02-14';

4. actor 테이블에서 이름first_name의 앞 세 글자만 출력-컬럼ACTOR
SELECT SUBSTRING(first_name, 1, 3) AS first_3_letters FROM actor;

5. 제목title이 앞 1글자가 A인 영화만 출력-컬럼FILM
SELECT * FROM film WHERE left(title,1) = 'A';

6. 제목이 N으로 끝나는 영화만 조회-컬럼FILM
select * from film WHERE right(title,1) = 'N';

7. film 테이블에서 제목을 출력하고 제목의 바이트 길이를 함께 표시-컬럼FILM
select title, length(title) AS byte_length FROM film;

8. customer 테이블에서 이름을 모두 대문자로 출력-컬럼CUSTOMER
SELECT upper(first_name) AS upper_name FROM customer;

9. actor 테이블에서 성을 모두 소문자로 출력-컬럼ACTOR
select LOWER(last_name) AS LOWER_NAME FROM actor;

10. actor 테이블에서 이름과 성을 붙여서 전체 이름 full_name으로 출력-컬럼ACTOR
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM actor;

11. customer 테이블에서 이름, 성, 이메일을 -로 구분해 출력-컬럼CUSTOMER
SELECT CONCAT(first_name, '-', last_name,'-',email) AS info FROM customer; 

12. film 테이블에서 제목 양쪽 공백 제거 후 출력-컬럼FILM
select trim(title) AS trimmed_title FROM film;

13. customer 테이블에서 이메일 주소에 "sakila"이 포함된 고객 찾으시오. -컬럼CUSTOMER
 SELECT * FROM customer WHERE email LIKE '%sakila%';

14. active 필드가 1인 직원 조회 -컬럼STAFF
select * from staff where activ = 1; 

15. 배우의 퍼스트 네임과 라스트 네임 조회
SELECT first_name, last name FROM actor;

16. 상영 시간 120 분 이상인 거만 출력 title, length
SELECT title, length FROM film WHERE length >= 120;

17. customer 테이블에서 이메일 주소에서 @를 (at)으로 바꾸어 출력하시오.
SELECT REPLACE(email, '@', '(at)') AS email_modified FROM customer;

18. film 테이블에서 title에 있는 'THE'를 '***'로 바꾸어 출력하시오.
SELECT REPLACE(title, 'THE', '***') AS title_modified FROM film;

19. customer 테이블에서 이메일에 '@'가 몇 번째 위치에 있는지 출력하시오.
SELECT email, locate('@', email) AS email_modified FROM customer;

20. film 테이블에서 제목의 4~8번째 글자를 출력하시오.
select substring(title, 4, 8) AS title_part FROM film;

21. payment 테이블에서 결제 금액을 소수점 첫째 자리로 반올림하여 출력하시오.
SELECT round(amount, 1)AS rounded_amount FROM payment;

22. 랜덤으로 영화 5개를 출력하시오.
select * from film order by rand() limit 5;

23. rental_date, return_date 중 더 늦은 날짜를 출력하시오.
select rental_id, rental_date, return_date, greatest(rental_date, return_date) AS later_date FROM rental; 

24. customer 테이블에서 활성화되지 않은 고객만 출력하시오.
select * from customer where active = 0;

25. 고객 ID를 5자리 숫자로 왼쪽 0으로 채워서 출력하시오.
select lpad(customer_id, 6, 0) AS padded_id FROM customer;
*
26. customer 테이블에서 고객이 속한 store_id별로 고객 수를 구하시오.
select store_id, count(*) AS customer_count FROM customer group by store_id;

27. payment 테이블에서 가장 결제를 많이 한 고객 ID 상위 5명을 구하시오.
select customer_id, count(*) AS payment_count FROM payment group by customer_id order by payment_count DESC limit 5;

28. rental 테이블에서 고객별 대여 횟수를 구하고, 30회 이상 대여한 고객만 출력하시오.
select customer_id, count(*) AS rental_count FROM rental group by customer_id order by rental_count <= 30;

29. film 테이블에서 길이(length)가 100분 이상인 영화들의 등급별 평균 길이를 구하시오.
select rating, avg(length) AS avg_length FROM film where length >= 100 GROUP BY rating;

30. payment 테이블에서 고객별 평균 결제 금액이 5 이상인 경우만 출력하시오.
select customer_id, avg(amount) AS avg_payment FROM payment group by customer_id having avg_payment >= 5;
*
31. rental 테이블과 customer 테이블을 조인하여 고객 이름과 대여일을 출력하시오
SELECT CONCAT(c.first_name, ' ', c.last_name) AS customer_name, r.rental_date
FROM rental r JOIN customer c ON r.customer_id = c.customer_id;

32. film_category. film, category 테이블을 조인해 영화 제목과 장르를 출력
select f.title, c.name AS category FROM film_category fc JOIN film f ON fc.film_id = f.film_id
JOIN category c ON fc.category_id = c.category_id; 

33. rental, inventory, film 테이블을 조인하여 대여된 영화 제목과 대여일을 출력하시오
select f.title, r.rental_date FROM rental r
JOIN inventory i ON r.inventory_id = i.inventory_id JOIN film f ON i.film_id = f.film_id; 

34. film 테이블에서 출연 배우가 5명 이상인 영화 제목을 출력하시오
select f.title from film f
join film_actor fa ON f.film_id = fa.film_id
group by f.film_id, f.title HAVING COUNT(fa.actor_id) >= 5;

35. rental 테이블에서 영화 제목과 반납되지 않은 대여 건만 조회하시오
select f.title, r.rental_date FROM rental r JOIN inventory i on
r.inventory_id = i.inventory_id JOIN film f ON i.film_id = f.film_id
WHERE r.return_date IS NULL;
*
36. 평균 rental_rate보다 높은 영화의 제목과 요금을 출력하시오. 
SELECT title, rental_rate FROM film WHERE rental_rate > (SELECT AVG(rental_rate) FROM film);

37. 총 결제 금액이 가장 많은 고객의 ID와 이름을 출력하시오. 
SELECT customer_id, first_name, last_name FROM customer
WHERE customer_id = (
SELECT customer_id FROM payment
GROUP BY customer_id
ORDER BY SUM(amount) DESC
LIMIT 1 );

38. 배우 중에서 출연한 영화 수가 가장 많은 배우의 이름과 영화 수를 출력하시오
SELECT concat(a.first_name, '', a.last_name) AS actor_name,
COUNT(fa.film_id) AS film_count FROM actor a
JOIN film_actor fa ON a.actor_id = fa.actor_id group by a.actor_id
ORDER BY film_count DESC LIMIT 1;

39. 가장 많이 대여된 영화 제목 Top10 과 그 대여 횟수를 출력하시오.
SELECT f.title, COUNT(r.rental_id) AS rental_count
FROM rental r 
JOIN inventory i ON r.inventory_ID = i.inventory_id
JOIN film f ON i.film_id = f.film_id
GROUP BY f.film_id 
ORDER BY rental_count DESC LIMIT 10;

40. 매장(store)별 총 수익(결제 금액 합계)을 출력하시오.
select s.store_id, SUM(p.amount) AS total_revenue FROM payment p
JOIN staff st ON p.staff_id = st.staff_id
JOIN store s ON st.store_id = s.store_id
GROUP BY s.store_id;

41. 장르(category)별 평균 영화 길이를 구하고, 가장 긴 평균 시간을 가진 장르를 출력하시오.
SELECT c.name AS category_name, AVG(f.length) AS avg_length
FROM film f
JOIN film_category fc ON f.film_id = fc.film_id
JOIN category c ON fc.category_id = c.category_id
GROUP BY c.category_id
ORDER BY avg_length DESC LIMIT 1;

42. 가장 많은 결제를 한 고객의 이름과 총 결제 금액을 구하시오.
SELECT CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
SUM(p.amount) AS total_payment
FROM payment p
JOIN customer c ON p.customer_id = c.customer_id
GROUP BY c.customer_id
ORDER BY total_payment DESC
LIMIT 1;

43. film 테이블에서 replacement_cost가 가장 비싼 영화의 제목과 금액을 출력하시오.
SELECT title, replacement_cost FROM film
WHERE replacement_cost = (SELECT MAX(replacement_cost) FROM film);

44. 자신이 대여한 영화 수가 평균 이상인 고객의 이름을 출력하시오.
select concat(c.first_name, '', c.last_name) AS customer_name 
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
group by c.customer_id
having count(r.rental_id) >= (
select avg(rental_count) FROM(
select count(*) AS rental_count FROM rental
GROUP BY customer_id 
) AS sub 				_ 이거 했는지 명심할 것
);

45. customer, address, city, country 테이블을 조인하여 고객 이름과 고객이 거주하는 국가명을 출력하시오.
SELECT CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
co.country AS country_name
FROM customer c
JOIN address a ON c.address_id = a.address_id
JOIN city ci ON a.city_id = ci.city_id
JOIN country co ON ci.country_id = co.country_id;